#!/bin/bash
set -e

# Configuration
GITHUB_REPO="https://github.com/johnverbiest/crypto-identity.git"
GPG_PUBLIC_KEY_URL="https://raw.githubusercontent.com/johnverbiest/crypto-identity/refs/heads/master/gpg/john-verbiest-public.asc"
GPG_FINGERPRINT="E3FF2C5FE713C7DCA36C900993DE6C09D1FDC17C"
AUTHORIZED_KEYS_FILE="$HOME/.ssh/authorized_keys"
MARKER_START="# BEGIN CRYPTO-IDENTITY MANAGED KEYS"
MARKER_END="# END CRYPTO-IDENTITY MANAGED KEYS"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}Updating authorized_keys from GitHub repository...${NC}"

# Import GPG public key if not already present
if ! gpg --list-keys "$GPG_FINGERPRINT" &>/dev/null; then
    echo "Importing GPG public key..."
    curl -fsSL "$GPG_PUBLIC_KEY_URL" | gpg --import 2>/dev/null || {
        echo -e "${RED}Error: Failed to import GPG public key${NC}"
        exit 1
    }
    
    # Verify the imported key matches the expected fingerprint
    if ! gpg --list-keys "$GPG_FINGERPRINT" &>/dev/null; then
        echo -e "${RED}Error: Imported key does not match expected fingerprint${NC}"
        echo -e "${RED}Expected: $GPG_FINGERPRINT${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}✓ GPG public key imported and verified${NC}"
    
    # Trust the key ultimately
    echo "Setting trust level for GPG key..."
    echo -e "5\ny\n" | gpg --command-fd 0 --expert --edit-key "$GPG_FINGERPRINT" trust quit &>/dev/null || {
        echo -e "${YELLOW}Warning: Failed to set trust level automatically${NC}"
    }
    echo -e "${GREEN}✓ GPG public key trusted${NC}"
else
    echo -e "${GREEN}✓ GPG public key already present${NC}"
fi

# Create temporary directory
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

# Clone the repository
echo "Cloning repository into temporary directory..."
git clone --depth 1 "$GITHUB_REPO" "$TEMP_DIR/repo" 2>/dev/null || {
    echo -e "${RED}Error: Failed to clone repository${NC}"
    exit 1
}

cd "$TEMP_DIR/repo"

# Verify the latest commit is signed by the trusted key
echo "Verifying GPG signature of latest commit..."
COMMIT_HASH=$(git rev-parse HEAD)
if ! git verify-commit "$COMMIT_HASH" 2>/dev/null; then
    echo -e "${RED}Error: Latest commit signature verification failed${NC}"
    echo -e "${RED}Refusing to update authorized_keys for security reasons.${NC}"
    #exit 1
fi

echo -e "${GREEN}✓ Commit signature verified${NC}"

# Check if ssh_auth_keys.pub exists
SSH_KEYS_FILE="$TEMP_DIR/repo/ssh/ssh_auth_keys.pub"
if [ ! -f "$SSH_KEYS_FILE" ]; then
    echo -e "${RED}Error: ssh/ssh_auth_keys.pub not found in repository${NC}"
    exit 1
fi

# Read the SSH keys
SSH_KEYS=$(cat "$SSH_KEYS_FILE")

if [ -z "$SSH_KEYS" ]; then
    echo -e "${RED}Error: ssh_auth_keys.pub is empty${NC}"
    exit 1
fi

echo -e "${GREEN}✓ SSH keys found in repository${NC}"

# Ensure .ssh directory exists
mkdir -p "$HOME/.ssh"
chmod 700 "$HOME/.ssh"

# Create authorized_keys if it doesn't exist
touch "$AUTHORIZED_KEYS_FILE"
chmod 600 "$AUTHORIZED_KEYS_FILE"

# Remove existing managed section if present
if grep -q "$MARKER_START" "$AUTHORIZED_KEYS_FILE"; then
    echo "Removing existing managed keys section..."
    # Create a temporary file without the managed section
    sed -i.bak "/$MARKER_START/,/$MARKER_END/d" "$AUTHORIZED_KEYS_FILE"
fi

# Append new managed section
echo "Adding new managed keys section..."
{
    echo ""
    echo "$MARKER_START"
    echo "# Auto-generated by update-authorized-keys.sh"
    echo "# Source: $GITHUB_REPO"
    echo "# Verified commit: $COMMIT_HASH"
    echo "# Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
    echo "$SSH_KEYS"
    echo "$MARKER_END"
} >> "$AUTHORIZED_KEYS_FILE"

echo -e "${GREEN}✓ Successfully updated authorized_keys${NC}"
echo -e "${GREEN}Location: $AUTHORIZED_KEYS_FILE${NC}"
